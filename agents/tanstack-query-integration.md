# üîÑ Guia de Integra√ß√£o TanStack Query para AI Agents

## ‚ö†Ô∏è IMPORTANTE: TanStack Query j√° est√° IMPLEMENTADO!

**TanStack Query est√° totalmente configurado e funcional neste projeto.** Este guia orienta AI agents sobre como **usar e estender** a implementa√ß√£o existente, n√£o como implementar do zero.

### ‚úÖ O que j√° est√° pronto:
- QueryClient configurado em `/src/lib/query-client.ts`
- Provider integrado em `/src/app/providers.tsx`
- Hooks de query em `/src/hooks/queries/`
- Hooks de mutation em `/src/hooks/mutations/`
- Demo funcional em `/tanstack-query`

## Contexto
Este projeto usa **TanStack Query** para gerenciamento de estado do servidor junto com **Zustand** para estado do cliente. Como AI agent, voc√™ deve seguir os padr√µes existentes ao adicionar novas features.

## üéØ State Separation Strategy

### ‚úÖ Continue Using Zustand For:
- UI state (theme, sidebar, modals, toasts)
- User preferences and app settings  
- Authentication status (derived from Clerk)
- Local application state
- Client-side notifications

### ‚úÖ Use TanStack Query For:
- API data fetching and caching
- User profiles and server data
- Posts, comments, any server-sourced data
- Real-time data synchronization
- Background updates and refetching
- Optimistic updates for better UX

## üì¶ Como Usar a Implementa√ß√£o Existente

### 1. Verificar a Configura√ß√£o Atual

```typescript
// ‚úÖ J√Å IMPLEMENTADO em src/lib/query-client.ts
import { queryClient } from '@/lib/query-client';

// Configura√ß√£o existente:
// - staleTime: 5 minutos
// - gcTime: 10 minutos (v5)
// - retry: l√≥gica inteligente para erros
// - refetchOnWindowFocus: false
```

### 2. Usar os Hooks Existentes

```typescript
// ‚úÖ HOOKS J√Å DISPON√çVEIS

// Queries (src/hooks/queries/)
import { useUserProfile, useCurrentUserProfile } from '@/hooks/queries/useUser';
import { usePosts, useMyPosts, usePublishedPosts } from '@/hooks/queries/usePosts';

// Mutations (src/hooks/mutations/)
import { useUpdateProfile } from '@/hooks/mutations/useProfile';
import { useCreatePost, useUpdatePost, useDeletePost } from '@/hooks/mutations/usePosts';
```

## üîß Padr√µes para Implementar Novas Features

### ‚ö†Ô∏è SEMPRE siga os padr√µes existentes ao criar novos hooks!

### Pattern 1: Criar Nova Query Hook (seguindo padr√£o existente)

```typescript
// ‚úÖ EXEMPLO: Adicionar query para coment√°rios seguindo o padr√£o dos posts

// src/hooks/queries/useComments.ts
import { useQuery } from '@tanstack/react-query';
import { useSupabase } from '@/hooks/useSupabase';
import { useUser } from '@clerk/nextjs';
import type { Database } from '@/lib/supabase/types';

// 1. Usar tipos do Supabase
type Comment = Database['public']['Tables']['comments']['Row'];

// 2. Seguir conven√ß√£o de nomenclatura
export function useComments(postId: string) {
  const supabase = useSupabase();
  
  return useQuery({
    queryKey: ['comments', postId], // Padr√£o: [recurso, identificador]
    queryFn: async (): Promise<Comment[]> => {
      const { data, error } = await supabase
        .from('comments')
        .select('*')
        .eq('post_id', postId)
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!postId, // Padr√£o: validar par√¢metros
  });
}

// 3. Varia√ß√µes espec√≠ficas (como em usePosts)
export function useMyComments() {
  const { user } = useUser();
  const supabase = useSupabase();
  
  return useQuery({
    queryKey: ['comments', 'my', user?.id],
    queryFn: async (): Promise<Comment[]> => {
      if (!user?.id) throw new Error('User not authenticated');
      
      const { data, error } = await supabase
        .from('comments')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!user?.id,
  });
}
```

### Pattern 2: Criar Nova Mutation (seguindo padr√£o existente)

```typescript
// ‚úÖ EXEMPLO: Adicionar mutation para coment√°rios seguindo o padr√£o dos posts

// src/hooks/mutations/useComments.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useShowToast } from '@/store'; // SEMPRE usar toast do Zustand
import { useSupabase } from '@/hooks/useSupabase';
import { useUser } from '@clerk/nextjs';
import type { Database } from '@/lib/supabase/types';

type CommentInsert = Database['public']['Tables']['comments']['Insert'];
type Comment = Database['public']['Tables']['comments']['Row'];

export function useCreateComment() {
  const queryClient = useQueryClient();
  const showToast = useShowToast(); // Padr√£o: toast via Zustand
  const supabase = useSupabase();
  const { user } = useUser();
  
  return useMutation({
    mutationFn: async (newComment: Omit<CommentInsert, 'user_id'>): Promise<Comment> => {
      if (!user?.id) throw new Error('User not authenticated');
      
      const { data, error } = await supabase
        .from('comments')
        .insert({
          ...newComment,
          user_id: user.id, // Sempre usar ID do Clerk
        })
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (createdComment) => {
      // Padr√£o: invalidar queries relacionadas
      queryClient.invalidateQueries({ queryKey: ['comments', createdComment.post_id] });
      
      // Padr√£o: mostrar toast de sucesso
      showToast({
        type: 'success',
        message: 'Coment√°rio adicionado com sucesso!'
      });
    },
    onError: (error: any) => {
      // Padr√£o: mostrar toast de erro
      showToast({
        type: 'error', 
        message: error.message || 'Falha ao adicionar coment√°rio'
      });
    },
  });
}
```

### Pattern 3: List with Optimistic Updates

```typescript
// src/hooks/queries/usePosts.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useSupabase } from '@/hooks/useSupabase';
import { useShowToast } from '@/store';

interface Post {
  id: string;
  title: string;
  content: string;
  user_id: string;
  created_at: string;
}

export function usePosts() {
  const supabase = useSupabase();
  
  return useQuery({
    queryKey: ['posts'],
    queryFn: async (): Promise<Post[]> => {
      const { data, error } = await supabase
        .from('posts')
        .select('*')
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      return data;
    },
  });
}

export function useCreatePost() {
  const queryClient = useQueryClient();
  const showToast = useShowToast();
  const supabase = useSupabase();
  
  return useMutation({
    mutationFn: async (newPost: Omit<Post, 'id' | 'created_at'>) => {
      const { data, error } = await supabase
        .from('posts')
        .insert(newPost)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onMutate: async (newPost) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries(['posts']);
      
      // Snapshot previous value
      const previousPosts = queryClient.getQueryData(['posts']);
      
      // Optimistically update the cache
      queryClient.setQueryData(['posts'], (old: Post[] = []) => [
        {
          ...newPost,
          id: 'temp-' + Date.now(),
          created_at: new Date().toISOString()
        },
        ...old
      ]);
      
      return { previousPosts };
    },
    onError: (error, newPost, context) => {
      // Rollback on error
      if (context?.previousPosts) {
        queryClient.setQueryData(['posts'], context.previousPosts);
      }
      showToast({
        type: 'error',
        message: 'Failed to create post'
      });
    },
    onSettled: () => {
      // Always refetch after error or success
      queryClient.invalidateQueries(['posts']);
    },
  });
}
```

### Pattern 4: Real-time Integration

```typescript
// src/hooks/queries/useRealtimePosts.ts
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useSupabase } from '@/hooks/useSupabase';
import { useEffect } from 'react';

export function useRealtimePosts() {
  const queryClient = useQueryClient();
  const supabase = useSupabase();
  
  // Base query
  const query = useQuery({
    queryKey: ['posts'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('posts')
        .select('*')
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      return data;
    },
  });
  
  // Real-time subscription
  useEffect(() => {
    const channel = supabase
      .channel('posts_changes')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'posts'
      }, (payload) => {
        // Invalidate and refetch on any change
        queryClient.invalidateQueries(['posts']);
      })
      .subscribe();
    
    return () => {
      channel.unsubscribe();
    };
  }, [queryClient, supabase]);
  
  return query;
}
```

### Pattern 5: Component Integration

```typescript
// src/components/UserProfile.tsx
import { useUser } from '@/hooks/queries/useUser';
import { useUpdateUser } from '@/hooks/mutations/useUpdateUser';
import { useTheme } from '@/store'; // Zustand for UI state

interface UserProfileProps {
  userId: string;
}

export function UserProfile({ userId }: UserProfileProps) {
  const theme = useTheme(); // Zustand UI state
  const { data: user, isLoading, error } = useUser(userId); // TanStack Query
  const updateUserMutation = useUpdateUser(); // TanStack Query + Zustand
  
  if (isLoading) {
    return <div className="animate-pulse">Loading...</div>;
  }
  
  if (error) {
    return (
      <div className="text-red-500">
        Error loading user: {error.message}
      </div>
    );
  }
  
  const handleUpdateName = () => {
    updateUserMutation.mutate({
      userId,
      data: { name: 'Updated Name' }
    });
  };
  
  return (
    <div className={`profile ${theme}`}>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      
      <button 
        onClick={handleUpdateName}
        disabled={updateUserMutation.isLoading}
        className="btn-primary"
      >
        {updateUserMutation.isLoading ? 'Updating...' : 'Update Name'}
      </button>
    </div>
  );
}
```

## üîë Query Key Management

```typescript
// src/lib/query-keys.ts
export const queryKeys = {
  users: {
    all: ['users'] as const,
    lists: () => [...queryKeys.users.all, 'list'] as const,
    list: (filters: string) => [...queryKeys.users.lists(), filters] as const,
    details: () => [...queryKeys.users.all, 'detail'] as const,
    detail: (id: string) => [...queryKeys.users.details(), id] as const,
  },
  posts: {
    all: ['posts'] as const,
    lists: () => [...queryKeys.posts.all, 'list'] as const,
    list: (filters: string) => [...queryKeys.posts.lists(), filters] as const,
    details: () => [...queryKeys.posts.all, 'detail'] as const,
    detail: (id: string) => [...queryKeys.posts.details(), id] as const,
  },
} as const;

// Usage
export function useUser(userId: string) {
  return useQuery({
    queryKey: queryKeys.users.detail(userId),
    queryFn: () => fetchUser(userId),
  });
}
```

## üö® Error Handling Patterns

### Global Error Handling

```typescript
// src/lib/query-client.ts
import { AxiosError } from 'axios';

export const queryClient = new QueryClient({
  queryCache: new QueryCache({
    onError: (error) => {
      // Global error handling
      if (error instanceof AxiosError) {
        if (error.response?.status === 401) {
          // Handle auth errors globally
          window.location.href = '/auth/sign-in';
          return;
        }
      }
      
      // Show generic error toast
      const showToast = useShowToast.getState();
      showToast({
        type: 'error',
        message: 'Something went wrong. Please try again.',
      });
    },
  }),
});
```

### Component Error Boundaries

```typescript
// src/components/QueryErrorBoundary.tsx
import { QueryErrorResetBoundary } from '@tanstack/react-query';
import { ErrorBoundary } from 'react-error-boundary';

function ErrorFallback({ error, resetErrorBoundary }: any) {
  return (
    <div className="error-fallback">
      <h2>Something went wrong:</h2>
      <pre>{error.message}</pre>
      <button onClick={resetErrorBoundary}>Try again</button>
    </div>
  );
}

export function QueryErrorBoundary({ children }: { children: React.ReactNode }) {
  return (
    <QueryErrorResetBoundary>
      {({ reset }) => (
        <ErrorBoundary
          onReset={reset}
          FallbackComponent={ErrorFallback}
        >
          {children}
        </ErrorBoundary>
      )}
    </QueryErrorResetBoundary>
  );
}
```

## üîÑ Migration Strategy

### 1. Keep Existing Zustand Stores
Don't change current UI and client state management:

```typescript
// ‚úÖ Keep these Zustand patterns
const theme = useTheme();
const showToast = useShowToast();
const sidebarOpen = useSidebarOpen();
const userPreferences = usePreferences();
```

### 2. Replace Server Data with TanStack Query

```typescript
// ‚ùå Remove from Zustand stores
interface AppStore {
  users: User[]; // Remove - use TanStack Query
  posts: Post[]; // Remove - use TanStack Query
  isLoadingUsers: boolean; // Remove - TanStack Query handles loading
}

// ‚úÖ Use TanStack Query instead
const { data: users, isLoading } = useUsers();
const { data: posts } = usePosts();
```

### 3. Migrate Gradually

1. **Start with read-only data** (GET requests)
2. **Add mutations** (POST, PUT, DELETE)
3. **Add real-time subscriptions**
4. **Remove server data from Zustand stores**

## üß™ Testing Patterns

```typescript
// src/test-utils/query-test-utils.ts
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { render } from '@testing-library/react';

export function createTestQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });
}

export function renderWithQuery(ui: React.ReactElement) {
  const testQueryClient = createTestQueryClient();
  return render(
    <QueryClientProvider client={testQueryClient}>
      {ui}
    </QueryClientProvider>
  );
}

// In tests
test('user profile loads correctly', async () => {
  const queryClient = createTestQueryClient();
  
  // Pre-populate cache
  queryClient.setQueryData(['user', 'test-id'], mockUser);
  
  const { findByText } = renderWithQuery(<UserProfile userId="test-id" />);
  
  expect(await findByText(mockUser.name)).toBeInTheDocument();
});
```

## üìä Performance Best Practices

### 1. Stale Time Configuration

```typescript
// Different stale times for different data types
const userQuery = useQuery({
  queryKey: ['user', userId],
  queryFn: fetchUser,
  staleTime: 10 * 60 * 1000, // User data: 10 minutes
});

const postsQuery = useQuery({
  queryKey: ['posts'],
  queryFn: fetchPosts,
  staleTime: 30 * 1000, // Posts: 30 seconds (more dynamic)
});
```

### 2. Background Updates

```typescript
// Show cached data immediately, update in background
const { data, isLoading, isFetching } = useQuery({
  queryKey: ['posts'],
  queryFn: fetchPosts,
  staleTime: 5 * 60 * 1000,
  refetchOnWindowFocus: true,
  refetchOnReconnect: true,
});

// Only show loading on initial load
if (isLoading) return <Spinner />;

// Show background update indicator
return (
  <div>
    {isFetching && <div className="text-sm">Updating...</div>}
    {/* Render data */}
  </div>
);
```

### 3. Selective Invalidation

```typescript
// Invalidate specific queries after mutations
const createPostMutation = useMutation({
  mutationFn: createPost,
  onSuccess: () => {
    // Only invalidate posts, not users
    queryClient.invalidateQueries(['posts']);
  },
});
```

## üîó Integration with Existing Features

### With Supabase RLS

```typescript
export function useUserPosts(userId: string) {
  const supabase = useSupabase(); // Uses Clerk token automatically
  
  return useQuery({
    queryKey: ['posts', 'user', userId],
    queryFn: async () => {
      // RLS automatically filters based on Clerk user
      const { data, error } = await supabase
        .from('posts')
        .select('*')
        .eq('user_id', userId);
      
      if (error) throw error;
      return data;
    },
    enabled: !!userId,
  });
}
```

### With Internationalization

```typescript
export function useLocalizedPosts() {
  const locale = useLocale(); // Zustand locale store
  
  return useQuery({
    queryKey: ['posts', 'localized', locale],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('posts')
        .select('*')
        .eq('language', locale);
      
      if (error) throw error;
      return data;
    },
  });
}
```

## üìÅ Recommended File Structure

```
src/
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ queries/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useUser.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ usePosts.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useComments.ts
‚îÇ   ‚îú‚îÄ‚îÄ mutations/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useUpdateUser.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useCreatePost.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useDeletePost.ts
‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ       ‚îú‚îÄ‚îÄ users.ts
‚îÇ       ‚îú‚îÄ‚îÄ posts.ts
‚îÇ       ‚îî‚îÄ‚îÄ comments.ts
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ query-client.ts
‚îÇ   ‚îî‚îÄ‚îÄ query-keys.ts
‚îî‚îÄ‚îÄ store/ (existing Zustand stores)
    ‚îú‚îÄ‚îÄ ui-store.ts
    ‚îú‚îÄ‚îÄ app-store.ts
    ‚îî‚îÄ‚îÄ locale-store.ts
```

## üéØ Resumo para AI Agents

### ‚úÖ O que J√Å EST√Å PRONTO:
1. **TanStack Query est√° IMPLEMENTADO** - n√£o precisa instalar ou configurar
2. **Hooks existentes** em `/src/hooks/queries/` e `/src/hooks/mutations/`
3. **Demo funcional** em `/tanstack-query` mostrando todos os padr√µes
4. **Integra√ß√£o completa** com Supabase RLS + Clerk JWT + Zustand

### üìã Checklist ao Adicionar Novas Features:

#### 1. Para Queries:
- [ ] Criar em `/src/hooks/queries/useNomeDoRecurso.ts`
- [ ] Usar tipos do Supabase: `type X = Database['public']['Tables']['tabela']['Row']`
- [ ] Seguir padr√£o de queryKey: `['recurso', identificador]`
- [ ] Usar `useSupabase()` para cliente
- [ ] Adicionar `enabled` para validar par√¢metros

#### 2. Para Mutations:
- [ ] Criar em `/src/hooks/mutations/useNomeDoRecurso.ts`
- [ ] Sempre usar `useShowToast()` do Zustand para feedback
- [ ] Usar `useUser()` do Clerk para autentica√ß√£o
- [ ] Invalidar queries relacionadas no `onSuccess`
- [ ] Implementar tratamento de erro no `onError`

#### 3. Para Componentes:
- [ ] Importar hooks de `/src/hooks/queries/` ou `/src/hooks/mutations/`
- [ ] Usar estados de loading: `isLoading`, `isPending`
- [ ] Mostrar erros apropriadamente
- [ ] Seguir padr√µes do demo em `/src/components/TanStackQuery/TanStackQueryDemo.tsx`

### ‚ö†Ô∏è NUNCA:
- ‚ùå Reinstalar TanStack Query (j√° est√° instalado)
- ‚ùå Recriar QueryClient (use o existente em `/src/lib/query-client.ts`)
- ‚ùå Modificar provider (j√° est√° configurado em `/src/app/providers.tsx`)
- ‚ùå Usar fetch direto (sempre use hooks do TanStack Query)
- ‚ùå Armazenar dados do servidor no Zustand (use TanStack Query)

### ‚úÖ SEMPRE:
- ‚úÖ Seguir os padr√µes dos hooks existentes
- ‚úÖ Usar TypeScript com tipos do Supabase
- ‚úÖ Integrar com Zustand para toasts
- ‚úÖ Respeitar RLS do Supabase com Clerk JWT
- ‚úÖ Verificar o demo antes de implementar

## üìö Refer√™ncias

- [Demo Funcional](/tanstack-query) - **VER PRIMEIRO!**
- [Documenta√ß√£o Completa](/docs/05-features/tanstack-query.md)
- [Hooks Implementados](/src/hooks/queries/ e /src/hooks/mutations/)
- [Componente Demo](/src/components/TanStackQuery/TanStackQueryDemo.tsx)